# Инструкция: Перевод проекта на Canvas-режим для дисплея AXS15231B (JC3248W535C)
===============================================================

## 1. Введение
-------------
Дисплей AXS15231B (3.5" 320x480, QSPI, JC3248W535C) требует работы через Canvas-режим библиотеки Arduino_GFX. Прямой вывод (без Canvas) не работает корректно. Для стабильной работы и совместимости все функции вывода должны быть переведены на Canvas.

## 2. Аппаратные пины (myoptions.h)
---------------------------------
Проверьте, что пины заданы так:
```
#define TFT_CS   45
#define TFT_RST  -1
#define TFT_SCK  47
#define TFT_D0   21
#define TFT_D1   48
#define TFT_D2   40
#define TFT_D3   39
#define GFX_BL   1
```

## 3. Инициализация Canvas
------------------------
В файле `displayAXS15231B.cpp`:
- Создайте глобальные объекты:
```cpp
static Arduino_DataBus *bus = nullptr;
static Arduino_GFX *output_display = nullptr;
static Arduino_Canvas *gfx = nullptr;
```
- В функции `initDisplay()` инициализируйте их:
```cpp
if (!bus) {
    bus = new Arduino_ESP32QSPI(TFT_CS, TFT_SCK, TFT_D0, TFT_D1, TFT_D2, TFT_D3);
}
if (!output_display) {
    output_display = new Arduino_AXS15231B(bus, TFT_RST, 0, false, 320, 480, 0, 0, 0, 0);
}
if (!gfx) {
    gfx = new Arduino_Canvas(320, 480, output_display);
    gfx->begin();
}
```

## 4. Использование GFX_Canvas_screen
----------------------------------
Для упрощения работы с Canvas мы создали библиотеку-обертку `GFX_Canvas_screen`. Она содержит все необходимые функции для работы с дисплеем:

### 4.1. Основные функции:
```cpp
// Текст
// Выводит текст с поддержкой UTF-8 на экран с указанными параметрами форматирования
void gfxDrawText(Arduino_Canvas* gfx, int x, int y, const char* text, uint16_t color, uint16_t bgcolor, uint8_t size, const GFXfont* font);
// gfx - указатель на объект Canvas
// x, y - координаты начала текста
// text - текст для вывода (поддерживает UTF-8)
// color - цвет текста (RGB565)
// bgcolor - цвет фона (RGB565)
// size - размер текста (1-8)
// font - указатель на шрифт (nullptr для встроенного)

// Выводит целое число на экран с указанными параметрами форматирования
void gfxDrawNumber(Arduino_Canvas* gfx, int x, int y, int num, uint16_t color, uint16_t bgcolor, uint8_t size, const GFXfont* font);
// gfx - указатель на объект Canvas
// x, y - координаты начала числа
// num - число для вывода
// color - цвет текста (RGB565)
// bgcolor - цвет фона (RGB565)
// size - размер текста (1-8)
// font - указатель на шрифт (nullptr для встроенного)

// Выводит форматированный текст (аналогично printf) с поддержкой UTF-8
void gfxDrawFormatted(Arduino_Canvas* gfx, int x, int y, const char* fmt, uint16_t color, uint16_t bgcolor, uint8_t size, const GFXfont* font, ...);
// gfx - указатель на объект Canvas
// x, y - координаты начала текста
// fmt - строка формата (как в printf)
// color - цвет текста (RGB565)
// bgcolor - цвет фона (RGB565)
// size - размер текста (1-8)
// font - указатель на шрифт (nullptr для встроенного)
// ... - переменные аргументы для форматирования

// Графика
// Рисует один пиксель указанного цвета
void gfxDrawPixel(Arduino_Canvas* gfx, int x, int y, uint16_t color);
// gfx - указатель на объект Canvas
// x, y - координаты пикселя
// color - цвет пикселя (RGB565)

// Рисует линию между двумя точками
void gfxDrawLine(Arduino_Canvas* gfx, int x0, int y0, int x1, int y1, uint16_t color);
// gfx - указатель на объект Canvas
// x0, y0 - координаты начала линии
// x1, y1 - координаты конца линии
// color - цвет линии (RGB565)

// Рисует контур прямоугольника
void gfxDrawRect(Arduino_Canvas* gfx, int x, int y, int w, int h, uint16_t color);
// gfx - указатель на объект Canvas
// x, y - координаты левого верхнего угла
// w - ширина прямоугольника
// h - высота прямоугольника
// color - цвет контура (RGB565)

// Рисует заполненный прямоугольник
void gfxFillRect(Arduino_Canvas* gfx, int x, int y, int w, int h, uint16_t color);
// gfx - указатель на объект Canvas
// x, y - координаты левого верхнего угла
// w - ширина прямоугольника
// h - высота прямоугольника
// color - цвет заливки (RGB565)

// Выводит растровое изображение из массива пикселей
void gfxDrawBitmap(Arduino_Canvas* gfx, int x, int y, const uint16_t* bitmap, int w, int h);
// gfx - указатель на объект Canvas
// x, y - координаты левого верхнего угла
// bitmap - указатель на массив пикселей (RGB565)
// w - ширина изображения
// h - высота изображения

// Очистка
// Очищает указанную область экрана указанным цветом
void gfxClearArea(Arduino_Canvas* gfx, int x, int y, int w, int h, uint16_t bgcolor);
// gfx - указатель на объект Canvas
// x, y - координаты левого верхнего угла области
// w - ширина области
// h - высота области
// bgcolor - цвет заливки (RGB565)

// Очищает весь экран указанным цветом
void gfxClearScreen(Arduino_Canvas* gfx, uint16_t bgcolor);
// gfx - указатель на объект Canvas
// bgcolor - цвет заливки всего экрана (RGB565)

// Обновляет экран, выводя содержимое буфера Canvas
void gfxFlushScreen(Arduino_Canvas* gfx);
// gfx - указатель на объект Canvas
// Обновляет экран, выводя содержимое буфера Canvas
```

### 4.2. Пример использования:
```cpp
// Очистка экрана
gfxClearScreen(gfx, BLACK);

// Вывод текста
gfxDrawText(gfx, 10, 10, "Hello", RED, BLACK, 2, &FreeSansBold12pt7b);

// Рисование прямоугольника
gfxFillRect(gfx, 50, 50, 100, 50, BLUE);

// Обновление экрана
gfxFlushScreen(gfx);
```

## 5. Вывод на экран
------------------
**Весь вывод (текст, графика, заливки и т.д.) должен идти через функции GFX_Canvas_screen:**
- Используйте функции из GFX_Canvas_screen вместо прямых вызовов Arduino_GFX
- После любого изменения вызывайте `gfxFlushScreen(gfx);` для отображения на экране

## 6. Запрет прямого вывода
-------------------------
- Не используйте методы Arduino_GFX напрямую
- Все рисование только через функции GFX_Canvas_screen
- Не используйте старые методы вывода!

## 7. Перевод функций
------------------
- Все функции, которые раньше работали с дисплеем напрямую, должны быть переписаны для работы с GFX_Canvas_screen
- Пример:
    - Было: `fillScreen(BLACK);`
    - Стало: `gfxClearScreen(gfx, BLACK); gfxFlushScreen(gfx);`

## 8. Особенности
---------------
- Canvas требует больше памяти (PSRAM обязателен!)
- После каждого изменения обязательно вызывать `gfxFlushScreen(gfx);`
- Не смешивайте разные методы вывода — это приводит к сбоям

## 9. Отладка
-----------
- Для теста используйте простые команды:
```cpp
gfxClearScreen(gfx, BLACK);
gfxDrawText(gfx, 10, 10, "Test", RED, BLACK, 2, nullptr);
gfxFlushScreen(gfx);
```
- Если экран белый — проверьте пины, питание, инициализацию Canvas

## 10. Переход на Canvas во всём проекте
-------------------------------------
- Все функции вывода (логотип, меню, плейлист, часы, VU-метр и т.д.) должны быть переписаны для работы с GFX_Canvas_screen
- После каждого блока рисования — `gfxFlushScreen(gfx);`
- Не используйте старые методы вывода!

## 11. Итог
----------
- Только Canvas-режим!
- Весь вывод — через GFX_Canvas_screen
- После каждого изменения — `gfxFlushScreen(gfx);`
- Не смешивать с прямым выводом!

ВАЖНО: Эта инструкция — основа для перевода всего проекта на Canvas-режим для AXS15231B. Используйте её как чек-лист для каждого этапа. 

## 12. ЛАЙФХАКИ И ОПТИМИЗАЦИЯ
----------------------------

### 12.1. Оптимизация памяти
- Используйте статические буферы для часто используемых изображений:
```cpp
static const uint16_t logo[] PROGMEM = { ... };
// Использование:
gfxDrawBitmap(gfx, x, y, logo, LOGO_WIDTH, LOGO_HEIGHT);
```

### 12.2. Оптимизация производительности
- Группируйте операции рисования и вызывайте `gfxFlushScreen` только после завершения группы:
```cpp
// Плохо:
gfxDrawText(gfx, x1, y1, "Text1", color, bg, size, font);
gfxFlushScreen(gfx);
gfxDrawText(gfx, x2, y2, "Text2", color, bg, size, font);
gfxFlushScreen(gfx);

// Хорошо:
gfxDrawText(gfx, x1, y1, "Text1", color, bg, size, font);
gfxDrawText(gfx, x2, y2, "Text2", color, bg, size, font);
gfxFlushScreen(gfx);
```

### 12.3. Работа с текстом
- Для часто используемых текстов создавайте макросы:
```cpp
#define DRAW_TITLE(x, y) gfxDrawText(gfx, x, y, "Title", TITLE_COLOR, BG_COLOR, 2, &TitleFont)
```
- Используйте `gfxDrawFormatted` для динамического текста:
```cpp
gfxDrawFormatted(gfx, x, y, "Volume: %d%%", color, bg, size, font, volume);
```

### 12.4. Работа с цветами
- Создайте константы для часто используемых цветов:
```cpp
#define MENU_BG    0x0000  // Черный
#define MENU_TEXT  0xFFFF  // Белый
#define MENU_SEL   0x07E0  // Зеленый
```
- Используйте макросы для создания цветов RGB565:
```cpp
#define RGB565(r, g, b) (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3))
```

### 12.5. Отладка
- Используйте Serial для отладки проблем с Canvas:
```cpp
Serial.printf("Drawing at x=%d, y=%d, color=0x%04X\n", x, y, color);
```
- Добавьте проверки на ошибки инициализации:
```cpp
if (!gfx) {
    Serial.println("Error: Canvas initialization failed!");
    return;
}
```

### 12.6. Оптимизация обновления экрана
- Используйте частичное обновление для динамических элементов:
```cpp
// Обновляем только изменяющуюся часть экрана
gfxClearArea(gfx, x, y, w, h, bgcolor);
gfxDrawText(gfx, x, y, text, color, bgcolor, size, font);
gfxFlushScreen(gfx);
```

